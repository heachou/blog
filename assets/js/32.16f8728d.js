(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{535:function(t,a,e){"use strict";e.r(a);var s=e(6),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("h2",{attrs:{id:"hooks为什么不能在条件或循环中使用-其中的原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks为什么不能在条件或循环中使用-其中的原理是什么"}},[t._v("#")]),t._v(" hooks为什么不能在条件或循环中使用，其中的原理是什么？")]),t._v(" "),e("blockquote",[e("p",[t._v("因为初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 数组中。\n更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。如果写在条件或循环中，那么这个顺序就发生了变化，memoizedState 并不会感知到。")])]),t._v(" "),e("h2",{attrs:{id:"react15和react16的更新机制差异-为什么react16架构升级后就能中断更新-根据什么决定是否中断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react15和react16的更新机制差异-为什么react16架构升级后就能中断更新-根据什么决定是否中断"}},[t._v("#")]),t._v(" react15和react16的更新机制差异？为什么react16架构升级后就能中断更新，根据什么决定是否中断？")]),t._v(" "),e("h2",{attrs:{id:"类组件如何实现逻辑复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类组件如何实现逻辑复用"}},[t._v("#")]),t._v(" 类组件如何实现逻辑复用")]),t._v(" "),e("blockquote",[e("p",[t._v("类组件实现逻辑复用一般是通过高阶组件HOC来实现的，高阶组件就是一个函数，接受一个组件为参数，返回一个新的组件，\n还可以通过render props来实现，指的是使用一个值为函数的"),e("code",[t._v("prop")]),t._v("元素并调用它而不是实现自己的渲染逻辑。")])]),t._v(" "),e("h2",{attrs:{id:"react中setstate是同步还是异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react中setstate是同步还是异步"}},[t._v("#")]),t._v(" react中setState是同步还是异步？")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/17",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 中 setState 什么时候是同步的，什么时候是异步的"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("setState 有时是同步的，有时是异步的，\n在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state 。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。")])]),t._v(" "),e("p",[t._v("原因： 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。")]),t._v(" "),e("p",[t._v("注意： setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。、")]),t._v(" "),e("p",[t._v("setState 的行为是“异步”还是“同步”取决于 React 执行 setState 方法时的执行上下文①(ExecutionContext)。")]),t._v(" "),e("p",[e("strong",[t._v("这里所说的同步异步， 并不是真正的同步异步， 它还是同步执行的。这里的异步指的是多个state会合成到一起进行批量更新。")])]),t._v(" "),e("h2",{attrs:{id:"react中如何阻止冒泡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react中如何阻止冒泡"}},[t._v("#")]),t._v(" react中如何阻止冒泡")]),t._v(" "),e("h2",{attrs:{id:"react-diff-算法复杂度是多少"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-算法复杂度是多少"}},[t._v("#")]),t._v(" react diff 算法复杂度是多少？")]),t._v(" "),e("h2",{attrs:{id:"diff-造成的非预期更新如何解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-造成的非预期更新如何解决"}},[t._v("#")]),t._v(" diff 造成的非预期更新如何解决？")]),t._v(" "),e("h2",{attrs:{id:"react-常用的性能优化手段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-常用的性能优化手段"}},[t._v("#")]),t._v(" react 常用的性能优化手段？")]),t._v(" "),e("h2",{attrs:{id:"react-redux-干了什么事情"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-redux-干了什么事情"}},[t._v("#")]),t._v(" react-redux 干了什么事情？")]),t._v(" "),e("h2",{attrs:{id:"mapstatetoprops-的第二个参数作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapstatetoprops-的第二个参数作用"}},[t._v("#")]),t._v(" mapStateToProps 的第二个参数作用？")]),t._v(" "),e("h2",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" CSS")]),t._v(" "),e("h2",{attrs:{id:"页面适配方案-百分比-flex-vh-vw"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页面适配方案-百分比-flex-vh-vw"}},[t._v("#")]),t._v(" 页面适配方案：百分比，flex,vh,vw")]),t._v(" "),e("h2",{attrs:{id:"浏览器相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器相关"}},[t._v("#")]),t._v(" 浏览器相关")]),t._v(" "),e("h2",{attrs:{id:"说下tls握手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说下tls握手"}},[t._v("#")]),t._v(" 说下tls握手")]),t._v(" "),e("h2",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),e("h2",{attrs:{id:"从地址栏输入地址到页面回显-都发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从地址栏输入地址到页面回显-都发生了什么"}},[t._v("#")]),t._v(" 从地址栏输入地址到页面回显，都发生了什么")]),t._v(" "),e("h2",{attrs:{id:"解释重绘会回流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解释重绘会回流"}},[t._v("#")]),t._v(" 解释重绘会回流")]),t._v(" "),e("h2",{attrs:{id:"js相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js相关"}},[t._v("#")]),t._v(" js相关")]),t._v(" "),e("h2",{attrs:{id:"new-promise返回的实例和实例then方法执行后返回的promise是一个吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-promise返回的实例和实例then方法执行后返回的promise是一个吗"}},[t._v("#")]),t._v(" new Promise返回的实例和实例then方法执行后返回的promise是一个吗？")]),t._v(" "),e("h2",{attrs:{id:"手写promise-promise里都是微任务吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写promise-promise里都是微任务吗"}},[t._v("#")]),t._v(" 手写promise（Promise里都是微任务吗）")]),t._v(" "),e("h2",{attrs:{id:"类数组怎么转换成数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类数组怎么转换成数组"}},[t._v("#")]),t._v(" 类数组怎么转换成数组")]),t._v(" "),e("h2",{attrs:{id:"如何改变this指向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何改变this指向"}},[t._v("#")]),t._v(" 如何改变this指向")]),t._v(" "),e("h2",{attrs:{id:"foreach-for-in-for-of-的差异"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#foreach-for-in-for-of-的差异"}},[t._v("#")]),t._v(" forEach for in for of 的差异")]),t._v(" "),e("h2",{attrs:{id:"new-操作符做了什么-如何区分函数是new调用还是直接调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-操作符做了什么-如何区分函数是new调用还是直接调用"}},[t._v("#")]),t._v(" new 操作符做了什么？（如何区分函数是new调用还是直接调用）")]),t._v(" "),e("h2",{attrs:{id:"object-create-null-和-object-create-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-create-null-和-object-create-有什么区别"}},[t._v("#")]),t._v(" Object.create(null) 和 Object.create({})有什么区别")]),t._v(" "),e("h2",{attrs:{id:"js数据类型和存储方式-如何判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js数据类型和存储方式-如何判断"}},[t._v("#")]),t._v(" js数据类型和存储方式，如何判断")]),t._v(" "),e("h2",{attrs:{id:"实现一下es中的-extends"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现一下es中的-extends"}},[t._v("#")]),t._v(" 实现一下es中的 extends")]),t._v(" "),e("h2",{attrs:{id:"说一下es6中的类和java中的类的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下es6中的类和java中的类的区别"}},[t._v("#")]),t._v(" 说一下es6中的类和java中的类的区别")]),t._v(" "),e("h2",{attrs:{id:"js中如何实现函数重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js中如何实现函数重载"}},[t._v("#")]),t._v(" js中如何实现函数重载")]),t._v(" "),e("h2",{attrs:{id:"webpack-相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-相关"}},[t._v("#")]),t._v(" webpack 相关")]),t._v(" "),e("h2",{attrs:{id:"webpack-常见的配置项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-常见的配置项"}},[t._v("#")]),t._v(" webpack 常见的配置项")]),t._v(" "),e("h2",{attrs:{id:"webpack-动态加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-动态加载"}},[t._v("#")]),t._v(" webpack 动态加载？")]),t._v(" "),e("h2",{attrs:{id:"算法相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法相关"}},[t._v("#")]),t._v(" 算法相关")]),t._v(" "),e("h2",{attrs:{id:"实现一个map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现一个map"}},[t._v("#")]),t._v(" 实现一个map")]),t._v(" "),e("h2",{attrs:{id:"统计字符串中次数最多的字母"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#统计字符串中次数最多的字母"}},[t._v("#")]),t._v(" 统计字符串中次数最多的字母")]),t._v(" "),e("h2",{attrs:{id:"rgb转16进制函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rgb转16进制函数"}},[t._v("#")]),t._v(" rgb转16进制函数")]),t._v(" "),e("h2",{attrs:{id:"实现一个带缓存的求阶乘函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现一个带缓存的求阶乘函数"}},[t._v("#")]),t._v(" 实现一个带缓存的求阶乘函数")]),t._v(" "),e("h2",{attrs:{id:"两个compose的大概实现-reduce-的妙用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两个compose的大概实现-reduce-的妙用"}},[t._v("#")]),t._v(" 两个compose的大概实现，reduce 的妙用")]),t._v(" "),e("h2",{attrs:{id:"实现一个数组的扁平方法flat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现一个数组的扁平方法flat"}},[t._v("#")]),t._v(" 实现一个数组的扁平方法flat")]),t._v(" "),e("h2",{attrs:{id:"数组去重怎么实现-如何不用set实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组去重怎么实现-如何不用set实现"}},[t._v("#")]),t._v(" 数组去重怎么实现，如何不用set实现")]),t._v(" "),e("h2",{attrs:{id:"数组中一万个数据访问第一个和访问最后一个效率会有什么差异-为什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组中一万个数据访问第一个和访问最后一个效率会有什么差异-为什么"}},[t._v("#")]),t._v(" 数组中一万个数据访问第一个和访问最后一个效率会有什么差异，为什么")])])}),[],!1,null,null,null);a.default=r.exports}}]);